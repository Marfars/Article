# 属性动画和硬件加速

## 属性动画

### ViewPropertyAnimator

- 使用``view.animate``得到对应视图的``ViewPropertyAnimator``对象，通过对此对象操作来实现动画效果

  - translationX：沿x轴移动

  - rotation：旋转

  - scaleX：横向放缩

  - alpha：设置透明度

  - setDuration：动画时间

  - withStartAction：动画开始时的伴生行为

  - withEndAction：动画结束时的伴生行为（和withStartAction：动画开始时的伴生行为都必须在start方法调用前设置）

  - setStartDelay：动画开始前等待多久（此方法和start方法冲突）

### ObjectAnimator

假设现在有一个View中包含了radius属性，利用ViewPropertyAnimator我们无法直接改变其值实现动画，但我们可以通过这个类来实现动画

``` Java
val animator = ObjectAnimator.ofFloat(binding.avatar, "radius", 100.dp)
// 启动延时
animator.startDelay = 1000
animator.start()
```

同理我们可以使用此方法对自定义View中的其他值进行修改

- 比较大的一个缺点是一个Object只能附加一个动画，多个动画就要有多个Object

### Camera的保存

- 在使用之前调用```camera.save```方法对camera的属性进行保存

- 在使用之后调用```camera.restore```方法对camera的属性进行重置

- 中间必须穿插一次```camera.applyToCanvas```

- 执行保存操作可以避免重绘时在上次属性的基础上增加属性

### AnimatorSet

整体使用方法为创建对象，将需要被执行的动画（AnimatorObject对象）作为list传入set集合中，然后正常调用start方法即可，如以下代码

```Java

val bottomAnimator = ObjectAnimator.ofFloat(binding.avatar, "bottomFlip", 50f)
val topAnimator = ObjectAnimator.ofFloat(binding.avatar, "topFlip", 50f)
// 创建动画集
val animatorSet = AnimatorSet()
// 设置动画列表
animatorSet.playTogether(listOf(bottomAnimator, topAnimator))
// 启动动画
animatorSet.startDelay = 3000
animatorSet.duration = 2000
animatorSet.start()

```

- 多个动画一起执行可以使用playTogether

- 多个动画顺序执行可以使用playSequentially

### PropertyValuesHolder

> 和AnimatorSet相反，Set是将动画整合，梳理多个动画执行顺序，而PropertyValuesHolder是将单个动画进行拆分，使其执行更细致

```Java
// 创建出持有bottomFlip属性的Holder
val bottomFlipHolder = PropertyValuesHolder.ofFloat("bottomFlip", 60f)
// 创建出持有topFlip属性的Holder
val topFlipHolder = PropertyValuesHolder.ofFloat("topFlip", 60f)
// 创建出持有topRotation属性的Holder
val topRotationHolder = PropertyValuesHolder.ofFloat("topRotation", 270f)
// 创建出持有三个valueHolder的ObjectAnimator
val holderAnimator = ObjectAnimator.ofPropertyValuesHolder(view, bottomFlipHolder, topFlipHolder, topRotationHolder)
// 正常使用动画
holder.start()

```

- 按照上述的流程就可以创建出更细化的动画

### KeyFrame

> 此属性可以用来约定一个属性动画的关键节点，比如执行到百分之二十时动画应执行到什么地步，但是需要先约定好开始和结束的值

```Java
val length = 200f
// 开始节点
val keyFrameStart = Keyframe.ofFloat(0f, 0f)
// 执行至百分之五十时，整个动画只执行百分之二十
val keyFrameMiddle = Keyframe.ofFloat(0.5f, 0.2f * length)
// 结束节点
val ketFrameEnd = Keyframe.ofFloat(1f, length)
// 将关键帧和属性绑定
val keyHolder = PropertyValuesHolder.ofKeyframe("translationX", keyFrameStart, keyFrameMiddle, ketFrameEnd)
// 将关键帧设定的动画和视图绑定
val animator = ObjectAnimator.ofPropertyValuesHolder(binding.avatar, keyHolder)
animator.startDelay = 1000
animator.duration = 3000
animator.start()
```

- 像这种很细致的操作，使用AnimatorSet就很难做到

### Interpolator(差值器)

> 帮我们设置一个从时间完成度到动画完成度计算的公式，简而言之就是动画的完成曲线，以下是四种比较常见的差值器

- AccelerateInterpolator：加速差值器（适合出场动画）

- AccelerateDecelerateInterpolator：先加速后减速的差值器

- LinearInterpolator：匀速差值器

- DecelerateInterpolator：减速差值器

### TypeEvaluator

> 对指定类型精确的计算动画变化过程中的变化值

- PointFEvaluator的实现

- StringEvaluator的实现

## 硬件加速

### 硬件绘制

指的是使用专业硬件进行绘制，**硬件加速指的就是使用GPU进行绘制**

### 硬件绘制的限制

兼容性问题，部分canvas的draw方法是从某个api才开始支持的

### 离屏缓冲

- **建议使用Hardware级别的layer**

- 可以使用```setLayerType(LAYER_TYPE_HARDWARE, null)```，这个并不是开启硬件加速，而是开启离屏缓冲

- 这个操作会导致硬件重绘

- 如果传入的是LAYER_TYPE_SOFT_WARE，那就意味着要关闭硬件加速