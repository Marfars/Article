# 范围裁切和几何变换

## Canvas的范围裁切

### clipRect

### clipPath

### clipOutRect/clipOutPath: clipRect和clipPath的反面操作，会切除指定范围的额外区域

### 三个切割方法最好范围能小一点，精确一点。可以提升渲染效率

### clip和Xfermode相比，会存在一点毛边

### 和clip搭配的一般都会是save和restore。在两次裁切之间必须先save，然后restore

## Canvas的几何变换(后续的所有方法都是在移动canvas坐标系，初始坐标系和视图坐标系重合)

### translate(x,y)

### rotate(degree)

### scale(x,y)

### skew(x,y)

### 几何变换的技巧就是正着想，倒着写

- 比如我们要将一个bitmap绘制到(200, 300)，想的时候肯定是先绘制bitmap，然后移到(200, 300)。但实际写应该是先将坐标系移到(200, 300)，然后绘制bitmap

- 上个例子比较简单，如果碰到三维转换，就必须这么做。否则会转晕

### Matrix的几何变换

#### preTranslate和canvas的translate一样

### preRotate和canvas的rotate一样

### preScale和canvas的Scale一样

### preSkew和canvas的skew一样

### postTranslate、postRotate、postScale、postSkew就是pre方法的倒序执行

- 比如我们先执行postTranslate然后执行postRotate，绘制的时候就会先执行rotate对应的操作，然后执行translate对应的操作

- 再比如上面的例子，就可以先绘制bitmap，然后再调用postTranslate

- 这样就可以正着思考正着写

## Camera(用于三维变换)

### rotate(x, y, z)/rotateX(x)/rotateY(y)/rotateZ(z)

- y轴不是向下为正向，向上是正向

### canvas在做几何变换的时候会一起移动camera的投射点

### 一般会将camera的location的z轴沿负方向移动8个单位，即调用camera.setLocation(0f ,0f, -8f * resources.displayMetrics.density)，-8可以根据实际场景动态设置